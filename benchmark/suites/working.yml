- name: appBoth
  query: "(a -> b) -> (a -> c) -> a -> (b, c)"
  solution: "\\f g x -> (f x, g x)"
  source: "original"

#- name: intToBS
#  query: "Int64 -> ByteString"
#  solution: "toLazyByteString . int64Dec"
#  source: "original"

- name: test
  query: "Bool -> a -> Maybe a"
  solution: "\\arg0 arg1 -> bool Nothing (Just arg1) arg0"
  source: "original"

- name: both
  query: "(a -> b) -> (a, a) -> (b, b)"
  solution: "\\arg0 arg1 -> (arg0 (Data.Tuple.fst arg1), arg0 (Data.Tuple.snd arg1))"
  source: "original"

- name: firstJust
  query: "a -> [Maybe a] -> a"
  solution: "\\x xs -> Data.Maybe.fromMaybe x (Data.Maybe.listToMaybe (Data.Maybe.catMaybes xs))"
  source: "original"

# - name: groupList
#   query: "[(k, v)] -> Map k [v]"

- name: mapEither
  query: "(a -> Either b c) -> [a] -> ([b], [c])"
  solution: "\\f xs -> Data.Either.partitionEithers (Data.List.map f xs)"
  source: "original"

- name: mapMaybes
  query: "(a -> Maybe b) -> [a] -> Maybe b"
  solution: "\\f xs -> Data.Maybe.listToMaybe (Data.Maybe.mapMaybe f xs)"
  source: "original"

- name: mergeEither
  query: "Either a (Either a b) -> Either a b"
  solution: "\\arg0 -> Data.Either.either Left (Data.Either.either Left Right) arg0"
  source: "original"

- name: multiApp
  query: "(a -> b -> c) -> (a -> b) -> a -> c"
  solution: "\\f g x -> f x (g x)"
  source: "hoogle"

- name: singleList
  query: "Int -> [Int]"
  solution: "\\arg0 -> (:) arg0 []"
  source: "hoogle"

- name: head-tail
  query: "[a] -> (a,a)"
  solution: "\\arg1 -> (Data.List.head arg1, Data.List.last arg1)"
  source: "hoogle"

- name: head-rest
  query: "[a] -> (a, [a])"
  solution: "\\arg1 -> (Data.List.head arg1, Data.List.tail arg1)"
  source: "hoogle"

- name: pred-match
  query: "[a] -> (a -> Bool) -> Int"
  solution: "\\xs f -> Data.List.length (Data.List.filter f xs)"
  source: "hoogle"

- name: splitStr
  query: "String -> Char -> [String]"
  solution: "\\xs x -> Data.List.words (Data.List.map (\\y -> bool ' ' y (y == x)) xs)"
  source: "hoogle"

- name: splitAtFirst
  query: "a -> [a] -> ([a], [a])"
  solution: "\\x xs -> Data.List.splitAt (Data.Maybe.fromMaybe 0 (Data.List.elemIndex x xs)) xs"
  source: "hoogle"

- name: mbToEither
  query: "Maybe a -> b -> Either a b"
  solution: "\\mb x -> bool (Right x) (Left (Data.Maybe.fromJust mb)) (Data.Maybe.isJust mb)"
  source: "original"

- name: cartProduct
  query: "[a] -> [b] -> [[(a,b)]]"
  solution: "\\xs ys -> Data.List.map (\\x -> Data.List.map ((,) x) ys) xs"
  source: "original"

- name: multiAppPair
  query: "(a -> b, a -> c) -> a -> (b, c)"
  solution: "\\tp x -> (,) ((Data.Tuple.fst tp) x) ((Data.Tuple.snd tp) x)"
  source: "original"

# No useful solution. Head of map ?
- name: hoogle01
  query: "(a -> b) -> [a] -> b"
  solution: "\\f xs -> f (Data.List.head xs)"
  source: "hoogle"

- name: firstMatch
  query: "[a] -> (a -> Bool) -> a"
  solution: "\\xs f -> Data.List.head (Data.List.filter f xs)"
  source: "hoogle"

- name: firstMaybe
  query: "[Maybe a] -> a"
  solution: "\\arg0 -> Data.List.head (Data.Maybe.catMaybes arg0)"
  source: "hoogle"

- name: rights
  query: "[Either a b] -> Either a [b]"
  solution: "\\arg0 -> Right (Data.Either.rights arg0)"
  source: "hoogle"

- name: firstKey
  query: "[(a,b)] -> a"
  solution: "\\arg0 -> Data.Tuple.fst (Data.List.head arg0)"
  source: "hoogle"

- name: applyPair
  query: "(a -> b, a) -> b"
  solution: "\\arg0 -> (Data.Tuple.fst arg0) (Data.Tuple.snd arg0)"
  source: "stackOverflow"

# No solution?
# - name: cross
#   query: "(a, b) -> (a, b) -> (a, b)"
#   source: "hoogle"

- name: firstRight
  query: "[Either a b] -> Either a b"
  solution: "\\arg0 -> Right (Data.List.head (Data.Either.rights arg0))"
  source: "hoogle"

- name: maybe
  query: "Maybe a -> a -> Maybe a"
  solution: "\\mb x -> Just (Data.Maybe.fromMaybe x mb)"
  source: "hoogle"

- name: app3
  query: "(a -> b -> c -> d) -> a -> c -> b -> d"
  solution: "\\f x z y -> f x y z"
  source: "hoogle"

- name: appendN
  query: "Int -> [a] -> [a]"
  solution: "\\n xs -> Data.List.concat (Data.List.replicate n xs)"
  source: "hoogle"

- name: flatten
  query: "[[[a]]] -> [a]"
  solution: "\\xs -> Data.List.concat (Data.List.concat xs)"
  source: "stackOverflow"

- name: takeNdropM
  query: "Int -> Int -> [a] -> ([a], [a])"
  solution: "\\n m l -> (Data.List.take n l, Data.List.drop m l)"
  source: "stackOverflow"

- name: map
  query: "(a->b)->[a]->[b]"
  solution: "\\f xs -> Data.List.map f xs"
  source: "original"

- name: repl-funcs
  query: "(a->b)->Int->[a->b]"
  solution: "\\f n -> Data.List.replicate n f"
  source: "original"

- name: mbAppFirst
  query: "b -> (a -> b) -> [a] -> b"
  solution: "\\x f xs -> Data.Maybe.maybe x f (Data.Maybe.listToMaybe xs)"
  source: "original"

- name: 2partApp
  query: "(a->b)->(b->c)->[a]->[c]"
  solution: "\\f g xs -> Data.List.map g (Data.List.map f xs)"
  source: "original"

- name: zipWithResult
  query: "(a->b)->[a]->[(a,b)]"
  solution: "\\f xs -> Data.List.zip xs (Data.List.map f xs)"
  source: "hoogle"

- name: resolveEither
  query: "Either a b -> (a->b) -> b"
  solution: "\\x f -> Data.Either.either f id x"
  source: "original"

- name: applyNtimes
  query: "(a->a) -> a -> Int -> a"
  solution: "\\f x n -> Data.List.foldr ($) x (Data.List.replicate n f)"
  source: "hoogle"

- name: eitherTriple
  query: "Either a b -> Either a b -> Either a b"
  solution: "\\x y -> Data.Either.either Left (const (Data.Either.either Left Right y)) x"
  source: "hoogle"

- name: pipe
  query: "[(a -> a)] -> (a -> a)"
  solution: "\\xs x -> Data.List.foldr ($) x xs"
  source: "hoogle"

- name: indexesOf
  query: "([(a,Int)] -> [(a,Int)]) -> [a] -> [Int] -> [Int]"
  solution: "\\f xs ys -> Data.List.map Data.Tuple.snd (f (Data.List.zip xs ys))"
  source: "stackOverflow"

# - name: dotProduct
#   query: "[Int] -> [Int] -> Int"
#   solution: \x y -> sum (zipWith (*) x y)

# - name: appTuple
#   query: "(a -> a') -> (b -> b') -> (a, b) -> (a', b')"
#   solution: (f (fst t), g (snd t))

# - name: numElem
#   query: Eq a => [a] -> a -> Int
#   solution: length (elemIndices x xs)

- name: lookup
  query: "Eq a => [(a,b)] -> a -> b"
  solution: "\\xs k -> Data.Maybe.fromJust (Data.List.lookup k xs)"
  source: "hoogle"

# - name: intersperse
#   query: Show a => a -> [String] -> String
#   solution: intersperse (show arg1) arg0

# - name: convertToInt
#   query: Double -> Int

# - name: toText
#   query: Show a => a -> Text

# - name: toFloat
#   query: Float -> Int

# - name: c2i
#   query: Char -> Integer

# - name: a2i
#   query: Num a => a -> Int

# - name: reverseMap
#   query: Ord k, Ord v => Map k v -> Map v [k]

# - name: overlapCount
#   query: "Eq a => [a] -> [a] -> Int"

- name: mbElem
  query: "Eq a => a -> [a] -> Maybe a"
  solution: "\\x xs -> bool Nothing (Just x) (Data.List.elem x xs)"
  source: "hoogle"

# - name: convert
#   query: Int -> Int -> Float

- name: areEq
  query: "Eq a => a -> a -> Maybe a"
  solution: "\\x y -> bool (Just x) Nothing ((==) x y)"
  source: "hoogle"

# - name: d2i
#   query: Double -> Integer

# - name: keyOverlap
#   query: Ord k => Map k v -> Set k -> Set k
#   solution: Set.intersection arg0 (keySet arg1)

# - name: justMap
#   query: Ord k => [Maybe (k, v)] -> Map k v
#   solution: Map.fromList (catMaybe arg0)

# - name: removeListFromSet
#   query: Ord k => [k] -> Set k -> Set k
#   solution: (\\) arg0 (fromList arg1)

# - name: updateAllInMap
#   query: (v -> Maybe v) -> Map k v -> Map k v

- name: containsEdge
  query: "[Int] -> (Int,Int) -> Bool"
  solution: "\\xs (a,b) -> (a `Data.List.elem` xs) && (b `Data.List.elem` xs)"
  source: "stackOverflow"

- name: dedupe
  query: "Eq a => [a] -> [a]"
  solution: "\\xs -> Data.List.map Data.List.head (Data.List.group xs)"
  source: "original"

- name: inverseMap
  query: "[a -> b] -> a -> [b]"
  solution: "\\fs x -> Data.List.map ($ x) fs"
  source: "original"

- name: concatNTimes
  query: "Int -> [a] -> [a]"
  solution: "\\n xs -> Data.List.concat (Data.List.replicate n xs)"
  source: "original"
