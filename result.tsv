Name	Query	Time	dfsCounter	Solution
appBoth	(a -> b) -> (a -> c) -> a -> (b, c)	14.87		\arg0 arg1 arg2 -> ((arg0 arg2) , (arg1 arg2))
test	Bool -> a -> Maybe a	5.30		\arg0 arg1 -> Data.Bool.bool Data.Maybe.Nothing (Data.Maybe.Just arg1) arg0
both	(a -> b) -> (a, a) -> (b, b)	2.01		\arg0 arg1 -> ((arg0 (fst arg1)) , (arg0 (snd arg1)))
firstJust	a -> [Maybe a] -> a	16.44		\arg0 arg1 -> Data.Maybe.fromMaybe arg0 (Data.Maybe.listToMaybe (Data.Maybe.catMaybes arg1))
mapEither	(a -> Either b c) -> [a] -> ([b], [c])	2.48		\arg0 arg1 -> Data.Either.partitionEithers (GHC.List.map arg0 arg1)
mapMaybes	(a -> Maybe b) -> [a] -> Maybe b	4.47		\arg0 arg1 -> arg0 (GHC.List.last (GHC.List.init arg1))
mergeEither	Either a (Either a b) -> Either a b	2.46		\arg0 -> Data.Either.either Data.Either.Left Data.Function.id arg0
mbToEither	Maybe a -> b -> Either a b	1.53		\arg0 arg1 -> Data.Maybe.maybe (Data.Either.Right arg1) Data.Either.Left arg0
cartProduct	[a] -> [b] -> [[(a,b)]]	300.15	-	-
multiAppPair	(a -> b, a -> c) -> a -> (b, c)	3.00		\arg0 arg1 -> (((fst arg0) $ arg1) , ((snd arg0) $ arg1))
map	(a->b)->[a]->[b]	1.10		\arg0 arg1 -> GHC.List.map arg0 arg1
repl-funcs	(a->b)->Int->[a->b]	0.59		\arg0 arg1 -> GHC.List.replicate arg1 arg0
mbAppFirst	b -> (a -> b) -> [a] -> b	1.98		\arg0 arg1 arg2 -> Data.Maybe.maybe arg0 arg1 (Data.Maybe.listToMaybe arg2)
2partApp	(a->b)->(b->c)->[a]->[c]	1.88		\arg0 arg1 arg2 -> GHC.List.map arg1 (GHC.List.map arg0 arg2)
resolveEither	Either a b -> (a->b) -> b	1.73		\arg0 arg1 -> Data.Either.either arg1 Data.Function.id arg0
dedupe	Eq a => [a] -> [a]	5.44		\arg0 -> GHC.List.map GHC.List.head (Data.List.group arg0)
inverseMap	[a -> b] -> a -> [b]	2.57		\arg0 arg1 -> GHC.List.zipWith Data.Function.id arg0 (GHC.List.repeat arg1)
multiApp	(a -> b -> c) -> (a -> b) -> a -> c	2.34		\arg0 arg1 arg2 -> arg0 arg2 (arg1 arg2)
singleList	a -> [a]	1.27		\arg0 -> arg0 : []
head-last	[a] -> (a,a)	95.89		\arg0 -> ((GHC.List.head arg0) , (GHC.List.last arg0))
head-rest	[a] -> (a, [a])	0.91		\arg0 -> Data.Maybe.fromJust (GHC.List.uncons arg0)
pred-match	[a] -> (a -> Bool) -> Int	2.93		\arg0 arg1 -> GHC.List.length (GHC.List.filter arg1 arg0)
splitStr	String -> Char -> [String]	0.77		\arg0 arg1 -> GHC.List.repeat (Text.Show.showChar arg1 arg0)
splitAtFirst	a -> [a] -> ([a], [a])	16.75	-	-
hoogle01	(a -> b) -> [a] -> b	2.42		\arg0 arg1 -> arg0 (GHC.List.head arg1)
firstMatch	[a] -> (a -> Bool) -> a	3.02		\arg0 arg1 -> GHC.List.head (GHC.List.filter arg1 arg0)
firstMaybe	[Maybe a] -> a	1.54		\arg0 -> GHC.List.head (Data.Maybe.catMaybes arg0)
rights	[Either a b] -> Either a [b]	1.08		\arg0 -> Data.Either.Right (Data.Either.rights arg0)
firstKey	[(a,b)] -> a	0.84		\arg0 -> Data.Tuple.fst (GHC.List.head arg0)
firstRight	[Either a b] -> Either a b	1.47		\arg0 -> GHC.List.last (GHC.List.init arg0)
maybe	Maybe a -> a -> Maybe a	0.96		\arg0 arg1 -> Data.Maybe.Just (Data.Maybe.fromMaybe arg1 arg0)
app3	(a -> b -> c -> d) -> a -> c -> b -> d	1.08		\arg0 arg1 arg2 arg3 -> arg0 arg1 arg3 arg2
appendN	Int -> [a] -> [a]	5.55		\arg0 arg1 -> GHC.List.concat (GHC.List.replicate arg0 arg1)
zipWithResult	(a->b)->[a]->[(a,b)]	145.78		\arg0 arg1 -> GHC.List.zip arg1 (GHC.List.map arg0 arg1)
applyNtimes	(a->a) -> a -> Int -> a	9.86		\arg0 arg1 arg2 -> (GHC.List.iterate arg0 arg1) !! arg2
eitherTriple	Either a b -> Either a b -> Either a b	21.48		\arg0 arg1 -> Data.Bool.bool arg1 arg0 (Data.Either.isLeft arg0)
pipe	[(a -> a)] -> (a -> a)	2.02		\arg0 arg1 -> GHC.List.foldr Data.Function.id arg1 arg0
lookup	Eq a => [(a,b)] -> a -> b	0.96		\arg0 arg1 -> Data.Maybe.fromJust (GHC.List.lookup arg1 arg0)
mbElem	Eq a => a -> [a] -> Maybe a	2.45		\arg0 arg1 -> Data.Maybe.listToMaybe (GHC.List.dropWhile ((Data.Eq./=) arg0) arg1)
areEq	Eq a => a -> a -> Maybe a	300.12	-	-
applyPair	(a -> b, a) -> b	1.15		\arg0 -> (fst arg0) $ (snd arg0)
flatten	[[[a]]] -> [a]	1.70		\arg0 -> GHC.List.concat (GHC.List.concat arg0)
takeNdropM	Int -> Int -> [a] -> ([a], [a])	168.57		\arg0 arg1 arg2 -> ((fst (GHC.List.splitAt arg0 (GHC.List.take arg0 arg2))) , (snd (GHC.List.splitAt arg1 arg2)))
indexesOf	([(a,Int)] -> [(a,Int)]) -> [a] -> [Int] -> [Int]	300.11	-	-
containsEdge	[Int] -> (Int,Int) -> Bool	300.03	-	-
numElem	Eq a => [a] -> a -> Int	242.74	-	-
intersect	Eq a => [a] -> [a] -> [a]	300.11	-	-
